#region Copyright (C) 2007-2018 Team MediaPortal

/*
    Copyright (C) 2007-2018 Team MediaPortal
    http://www.team-mediaportal.com

    This file is part of MediaPortal 2

    MediaPortal 2 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MediaPortal 2 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MediaPortal 2. If not, see <http://www.gnu.org/licenses/>.
*/

#endregion

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Xml.Linq;
using MediaPortal.Common;
using MediaPortal.Common.Certifications;
using MediaPortal.Common.Logging;
using MediaPortal.Common.MediaManagement;
using MediaPortal.Common.MediaManagement.DefaultItemAspects;
using MediaPortal.Common.MediaManagement.Helpers;
using MediaPortal.Common.ResourceAccess;
using MediaPortal.Common.Services.GenreConverter;
using MediaPortal.Extensions.MetadataExtractors.NfoMetadataExtractors.Settings;
using MediaPortal.Extensions.MetadataExtractors.NfoMetadataExtractors.Stubs;
using MediaPortal.Utilities.Cache;

namespace MediaPortal.Extensions.MetadataExtractors.NfoMetadataExtractors.NfoReaders
{
  /// <summary>
  /// Reads the content of a nfo-file for series (tvshow.nfo) into <see cref="SeriesStub"/> objects. It does not
  /// write anything into the MediaItemsAspects because the SeriesStub objects need to be combined
  /// with the SeriesEpisodeStub object before writing to the MediaItemAspects, which is done in the
  /// NfoSeriesEpisodeReader.
  /// </summary>
  /// <remarks>
  /// There is a TryRead method for any known child element of the nfo-file's root element.
  /// There are no TryWrite mothods in this class; the <see cref="SeriesStub"/> objects generated by this class
  /// need to be taken (via <see cref="GetSeriesStubs"/>) and put into a <see cref="NfoSeriesEpisodeReader"/> object,
  /// which holds the appropriate TryWriteMethods to write information from both, <see cref="SeriesStub"/> and
  /// <see cref="SeriesEpisodeStub"/> objects into the appropriate MIA-Attributes.
  /// This class can parse much more information than we can currently store in our MediaLibrary.
  /// For performance reasons, the following long lasting operations have been temporarily disabled:
  /// - We do parse "set" (and therefore also "sets" elements); however, parsing and downloading
  ///   "setimage" child elements has been disabled. Reenable in <see cref="TryReadSetAsync"/>
  /// - We do parse "actor" elements, however, parsing and downloading "thumb"
  ///   child elements has been disabled. Reenable in <see cref="NfoReaderBase{T}.ParsePerson"/>
  /// - The following elements are completely ignored:
  ///   "thumb" and "fanart"
  ///   Reenable in <see cref="InitializeSupportedElements"/>
  /// ToDo: Reenable the above once we can store the information in our MediaLibrary
  /// </remarks>
  public class NfoSeriesReader : NfoReaderBase<SeriesStub>
  {
    #region Consts / static fields

    /// <summary>
    /// The name of the root element in a valid nfo-file for series
    /// </summary>
    private const string SERIES_ROOT_ELEMENT_NAME = "tvshow";

    /// <summary>
    /// Default timeout for the cache is 5 minutes
    /// </summary>
    private static readonly TimeSpan CACHE_TIMEOUT = new TimeSpan(0,5,0);

    /// <summary>
    /// Cache used to temporarily store <see cref="SeriesStub"/> objects so that the same tvshow.nfo file
    /// doesn't have to be parsed once for every episode
    /// </summary>
    private static readonly AsyncStaticTimeoutCache<ResourcePath, List<SeriesStub>> CACHE = new AsyncStaticTimeoutCache<ResourcePath, List<SeriesStub>>(CACHE_TIMEOUT);

    #endregion

    #region Private fields

    /// <summary>
    /// If true, episode details will also be read from the nfo-file
    /// </summary>
    private bool _readEpisodes;

    /// <summary>
    /// If true, file details will also be read from the nfo-file
    /// </summary>
    private bool _readFileDetails;

    #endregion

    #region Ctor

    /// <summary>
    /// Instantiates a <see cref="NfoSeriesReader"/> object
    /// </summary>
    /// <param name="debugLogger">Debug logger to log to</param>
    /// <param name="miNumber">Unique number of the MediaItem for which the nfo-file is parsed</param>
    /// <param name="importOnly">If true, this is an import only cycle meaning no refresh of existing media</param>
    /// <param name="forceQuickMode">If true, no long lasting operations such as parsing images are performed</param>
    /// <param name="readEpisodes">If true, episode details will also be read from the nfo-file</param>
    /// <param name="httpClient"><see cref="HttpClient"/> used to download from http URLs contained in nfo-files</param>
    /// <param name="settings">Settings of the <see cref="NfoSeriesMetadataExtractor"/></param>
    public NfoSeriesReader(ILogger debugLogger, long miNumber, bool forceQuickMode, bool readEpisodes, bool readFileDetails, HttpClient httpClient, NfoSeriesMetadataExtractorSettings settings)
      : base(debugLogger, miNumber, forceQuickMode, httpClient, settings)
    {
      _readEpisodes = readEpisodes;
      _readFileDetails = readFileDetails;
      _settings = settings;
      InitializeSupportedElements();
      InitializeSupportedAttributes();
    }

    #endregion

    #region Private methods

    #region Ctor helpers

    /// <summary>
    /// Adds a delegate for each xml element in a series nfo-file that is understood by this MetadataExtractor to NfoReaderBase._supportedElements
    /// </summary>
    private void InitializeSupportedElements()
    {
      _supportedElements.Add("id", new TryReadElementDelegate(TryReadId));
      _supportedElements.Add("code", new TryReadElementDelegate(TryReadCode));
      _supportedElements.Add("episodeguide", new TryReadElementDelegate(TryReadEpisodeGuide));

      _supportedElements.Add("title", new TryReadElementDelegate(TryReadTitle));
      _supportedElements.Add("showtitle", new TryReadElementDelegate(TryReadShowTitle));
      _supportedElements.Add("sorttitle", new TryReadElementDelegate(TryReadSortTitle));
      _supportedElements.Add("set", new TryReadElementAsyncDelegate(TryReadSetAsync));
      _supportedElements.Add("sets", new TryReadElementAsyncDelegate(TryReadSetsAsync));
      
      _supportedElements.Add("premiered", new TryReadElementDelegate(TryReadPremiered));
      _supportedElements.Add("year", new TryReadElementDelegate(TryReadYear));
      _supportedElements.Add("studio", new TryReadElementDelegate(TryReadStudio));
      _supportedElements.Add("actor", new TryReadElementAsyncDelegate(TryReadActorAsync));
      _supportedElements.Add("status", new TryReadElementDelegate(TryReadStatus));

      _supportedElements.Add("plot", new TryReadElementDelegate(TryReadPlot));
      _supportedElements.Add("outline", new TryReadElementDelegate(TryReadOutline));
      _supportedElements.Add("tagline", new TryReadElementDelegate(TryReadTagline));
      _supportedElements.Add("trailer", new TryReadElementDelegate(TryReadTrailer));
      _supportedElements.Add("genre", new TryReadElementDelegate(TryReadGenre));
      _supportedElements.Add("genres", new TryReadElementDelegate(TryReadGenres));

      _supportedElements.Add("thumb", new TryReadElementAsyncDelegate(TryReadThumbAsync));
      _supportedElements.Add("fanart", new TryReadElementAsyncDelegate(TryReadFanArtAsync));

      _supportedElements.Add("mpaa", new TryReadElementDelegate(TryReadMpaa));
      _supportedElements.Add("rating", new TryReadElementDelegate(TryReadRating));
      _supportedElements.Add("votes", new TryReadElementDelegate(TryReadVotes));
      _supportedElements.Add("top250", new TryReadElementDelegate(TryReadTop250));

      _supportedElements.Add("episodedetails", new TryReadElementAsyncDelegate(TryReadEpisodeAsync));

      // The following element readers have been added above, but are replaced by the Ignore method here for performance reasons
      // ToDo: Reenable the below once we can store the information in the MediaLibrary
      _supportedElements["thumb"] = new TryReadElementDelegate(Ignore);
      _supportedElements["fanart"] = new TryReadElementDelegate(Ignore);

      // The following elements are contained in many tvshow.nfo files, but have no meaning
      // in the context of a series. We add them here to avoid them being logged as
      // unknown elements, but we simply ignore them.
      // For reference see here: http://forum.team-mediaportal.com/threads/mp2-459-implementation-of-a-movienfometadataextractor-and-a-seriesnfometadataextractor.128805/page-13#post-1130414
      _supportedElements.Add("epbookmark", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("season", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("episode", new TryReadElementDelegate(Ignore)); // Kodi stores a value here, but the meaning is unclear
      _supportedElements.Add("displayseason", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("displayepisode", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("uniqueid", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("aired", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("runtime", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("playcount", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("lastplayed", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("resume", new TryReadElementDelegate(Ignore));
      _supportedElements.Add("dateadded", new TryReadElementDelegate(Ignore));
    }

    /// <summary>
    /// Adds a delegate for each Attribute in a MediaItemAspect into which this MetadataExtractor can write metadata to NfoReaderBase._supportedAttributes
    /// </summary>
    private void InitializeSupportedAttributes()
    {
      _supportedAttributes.Add(TryWriteMediaAspectTitle);
      _supportedAttributes.Add(TryWriteMediaAspectSortTitle);
      _supportedAttributes.Add(TryWriteMediaAspectRecordingTime);

      _supportedAttributes.Add(TryWriteSeriesAspectGenres);
      _supportedAttributes.Add(TryWriteSeriesAspectActors);
      _supportedAttributes.Add(TryWriteSeriesAspectDescription);
      _supportedAttributes.Add(TryWriteSeriesAspectTvDbId);
      _supportedAttributes.Add(TryWriteSeriesAspectSeriesName);
      _supportedAttributes.Add(TryWriteSeriesAspectTotalRating);
      _supportedAttributes.Add(TryWriteSeriesAspectRatingCount);
      _supportedAttributes.Add(TryWriteSeriesAspectEnded);
      _supportedAttributes.Add(TryWriteSeriesAspectCertification);
      _supportedAttributes.Add(TryWriteSeriesAspectNetworks);

      _supportedAttributes.Add(TryWriteThumbnailLargeAspectThumbnail);
    }

    #endregion

    #region Reader methods for direct child elements of the root element

    #region Internet databases

    /// <summary>
    /// Tries to read the thetvdb.com ID
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadId(XElement element)
    {
      // Example of a valid element:
      // <id>158661</id>
      return ((_currentStub.Id = ParseSimpleInt(element)) != null);
    }

    /// <summary>
    /// Tries to read the Production Code Number
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadCode(XElement element)
    {
      // Example of a valid element:
      // <code>A</code>
      return ((_currentStub.ProductionCodeNumber = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to read the Link to the Episode Guide
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadEpisodeGuide(XElement element)
    {
      // Example of a valid element:
      // <episodeguide>
      //   <url cache="83462-de.xml">http://thetvdb.com/api/1D62F2F90030C444/series/83462/all/de.zip</url>
      // </episodeguide>
      if (element == null || !element.HasElements)
        return false;
      if (element.Elements().Count() > 1)
        _debugLogger.Warn("[#{0}]: EpisodeGuide element has multiple child elements. Only using the first url child element {1}", _miNumber, element);
      var urlElements = element.Elements("url").ToList();
      if (!urlElements.Any())
      {
        _debugLogger.Warn("[#{0}]: EpisodeGuide element missing url child element {1}", _miNumber, element);
        return false;
      }
      return ((_currentStub.EpisodeGuide = ParseSimpleString(urlElements[0])) != null);
    }

    #endregion

    #region Title information

    /// <summary>
    /// Tries to read the title
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadTitle(XElement element)
    {
      // Example of a valid element:
      // <title>Castle</title>
      _currentStub.Title = ParseSimpleString(element);
      if (_currentStub.Title != null)
        _currentStub.ShowTitle = _currentStub.Title;
      return (_currentStub.Title != null);
    }

    /// <summary>
    /// Tries to read the show title
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadShowTitle(XElement element)
    {
      // Example of a valid element:
      // <showtitle>Castle</showtitle>
      return ((_currentStub.ShowTitle = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to read the sort title
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadSortTitle(XElement element)
    {
      // Example of a valid element:
      // <sorttitle>Star Trek02</sorttitle>
      return ((_currentStub.SortTitle = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to (asynchronously) read the set information
    /// We have not found an example for this element, yet, and assume it has the same structure as for movies.
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <param name="nfoDirectoryFsra"><see cref="IFileSystemResourceAccessor"/> to the parent directory of the nfo-file</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private async Task<bool> TryReadSetAsync(XElement element, IFileSystemResourceAccessor nfoDirectoryFsra)
    {
      // Examples of valid elements:
      // 1:
      // <set order = "1">Star Trek</set>
      // 2:
      // <set order = "1">
      //   <setname>Star Trek</setname>
      //   <setdescription>This is ...</setdescription>
      //   <setrule></setrule>
      //   <setimage></setimage>
      // </set>
      // The order attribute in both cases is optional.
      // In example 2 only the <setname> child element is mandatory.
      if (element == null)
        return false;

      var value = new SetStub();
      // Example 1:
      if (!element.HasElements)
        value.Name = ParseSimpleString(element);
      // Example 2:
      else
      {
        value.Name = ParseSimpleString(element.Element("setname"));
        value.Description = ParseSimpleString(element.Element("setdescription"));
        value.Rule = ParseSimpleString(element.Element("setrule"));
        value.TmdbId = ParseSimpleInt(element.Element("tmdbid"));
        if (!value.TmdbId.HasValue)
          value.TmdbId = ParseSimpleInt(element.Element("tmdbId"));
        if (!value.TmdbId.HasValue)
          value.TmdbId = ParseSimpleInt(element.Element("thmdb"));
        if (!value.TmdbId.HasValue)
          value.TmdbId = ParseSimpleInt(element.Element("tmdb"));
        //ToDo: Reenable parsing <setimage> child elements once we can store them in the MediaLibrary
        value.Image = await Task.FromResult<byte[]>(null); // ParseSimpleImageAsync(element.Element("setimage"), nfoDirectoryFsra).ConfigureAwait(false);
      }
      value.Order = ParseIntAttribute(element, "order");

      if (value.Name == null)
        return false;

      if (_currentStub.Sets == null)
        _currentStub.Sets = new HashSet<SetStub>();
      _currentStub.Sets.Add(value);
      return true;
    }

    /// <summary>
    /// Tries to (asynchronously) read the sets information
    /// We have not found an example for this element, yet, and assume it has the same structure as for movies.
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <param name="nfoDirectoryFsra"><see cref="IFileSystemResourceAccessor"/> to the parent directory of the nfo-file</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private async Task<bool> TryReadSetsAsync(XElement element, IFileSystemResourceAccessor nfoDirectoryFsra)
    {
      // Example of a valid element:
      // <sets>
      //   [any number of set elements that can be read by TryReadSetAsync]
      // </sets>
      if (element == null || !element.HasElements)
        return false;
      var result = false;
      foreach (var childElement in element.Elements())
        if (childElement.Name == "set")
        {
          if (await TryReadSetAsync(childElement, nfoDirectoryFsra).ConfigureAwait(false))
            result = true;
        }
        else
          _debugLogger.Warn("[#{0}]: Unknown child element: {1}", _miNumber, childElement);
      return result;
    }

    #endregion

    #region Making-of information

    /// <summary>
    /// Tries to read the premiered value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadPremiered(XElement element)
    {
      // Examples of valid elements:
      // <premiered>1994-09-14</premiered>
      // <premiered>1994</premiered>
      return ((_currentStub.Premiered = ParseSimpleDateTime(element)) != null);
    }

    /// <summary>
    /// Tries to read the year value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadYear(XElement element)
    {
      // Examples of valid elements:
      // <year>1994-09-14</year>
      // <year>1994</year>
      return ((_currentStub.Year = ParseSimpleDateTime(element)) != null);
    }

    /// <summary>
    /// Tries to read a studio value
    /// </summary>
    /// <param name="element">Element to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadStudio(XElement element)
    {
      // Example of a valid element:
      // <studio>SyFy</studio>
      return ((_currentStub.Studio = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to (asynchronously) read an actor value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <param name="nfoDirectoryFsra"><see cref="IFileSystemResourceAccessor"/> to the parent directory of the nfo-file</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private async Task<bool> TryReadActorAsync(XElement element, IFileSystemResourceAccessor nfoDirectoryFsra)
    {
      // For examples of valid element values see the comment in NfoReaderBase.ParsePerson
      var person = await ParsePerson(element, nfoDirectoryFsra).ConfigureAwait(false);
      if (person == null)
        return false;
      if (_currentStub.Actors == null)
        _currentStub.Actors = new HashSet<PersonStub>();
      _currentStub.Actors.Add(person);
      return true;
    }

    /// <summary>
    /// Tries to read a status value
    /// </summary>
    /// <param name="element">Element to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadStatus(XElement element)
    {
      // Example of a valid element:
      // <status>Continuing</status>
      return ((_currentStub.Status = ParseSimpleString(element)) != null);
    }

    #endregion

    #region Content information

    /// <summary>
    /// Tries to read the plot value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadPlot(XElement element)
    {
      // Example of a valid element:
      // <plot>This series tells a story about...</plot>
      return ((_currentStub.Plot = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to read the outline value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadOutline(XElement element)
    {
      // Example of a valid element:
      // <outline>This series tells a story about...</outline>
      return ((_currentStub.Outline = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to read the tagline value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadTagline(XElement element)
    {
      // Example of a valid element:
      // <tagline>This series tells a story about...</tagline>
      return ((_currentStub.Tagline = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to read the trailer value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadTrailer(XElement element)
    {
      // Example of a valid element:
      // <trailer>[URL to a trailer]</trailer>
      return ((_currentStub.Trailer = ParseSimpleString(element)) != null);
    }

    /// <summary>
    /// Tries to read a genre value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadGenre(XElement element)
    {
      // Examples of valid elements:
      // <genre>Horror</genre>
      // <genre>Horror / Trash</genre>
      return ((_currentStub.Genres = ParseCharacterSeparatedStrings(element, _currentStub.Genres)) != null);
    }

    /// <summary>
    /// Tries to read a genres value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadGenres(XElement element)
    {
      // Example of a valid element:
      // <genres>
      //  <genre>[genre-value]</genre>
      // </genres>
      // There can be one of more <genre> child elements
      // [genre-value] can be any value that can be read by TryReadGenre
      if (element == null || !element.HasElements)
        return false;
      var result = false;
      foreach (var childElement in element.Elements())
      {
        if (childElement.Name == "genre")
          result = TryReadGenre(childElement) || result;
        else
          _debugLogger.Warn("[#{0}]: Unknown child element: {1}", _miNumber, childElement);
      }
      return result;
    }

    /// <summary>
    /// Tries to (asynchronously) read an epsiode value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <param name="nfoDirectoryFsra"><see cref="IFileSystemResourceAccessor"/> to the parent directory of the nfo-file</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private async Task<bool> TryReadEpisodeAsync(XElement element, IFileSystemResourceAccessor nfoDirectoryFsra)
    {
      if (!_readEpisodes)
        return false;

      NfoSeriesEpisodeReader episodeNfoReader = new NfoSeriesEpisodeReader(_debugLogger, _miNumber, _forceQuickMode, _readFileDetails, _httpDownloadClient, (NfoSeriesMetadataExtractorSettings)_settings);
      // For examples of valid element values see the comment in NfoReaderBase.ParsePerson
      if(await episodeNfoReader.TryReadElementAsync(element, nfoDirectoryFsra).ConfigureAwait(false))
      {
        if (_currentStub.Episodes == null)
          _currentStub.Episodes = new HashSet<SeriesEpisodeStub>();
        foreach (SeriesEpisodeStub stub in episodeNfoReader.GetEpisodeStubs())         
          _currentStub.Episodes.Add(stub);

        return true;
      }
      return false;
    }

    #endregion

    #region Images

    /// <summary>
    /// Tries to (asynchronously) read a thumbnail image
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <param name="nfoDirectoryFsra"><see cref="IFileSystemResourceAccessor"/> to the parent directory of the nfo-file</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private async Task<bool> TryReadThumbAsync(XElement element, IFileSystemResourceAccessor nfoDirectoryFsra)
    {
      // Example of a valid element:
      // <thumb aspect="[aspect]" type="[type]" season="[season]" colors="[colors]">[ImageString]</thumb>
      //
      // [ImageString]: For examples see the comment of NfoReaderBase.ParseSimpleImageAsync
      // All attributes are optional
      // [aspect]: Can be "banner", "poster" and theoretically "fanart", but instead of an attribute, all fanart thumbs are child elements of <fanart>
      // [type]:  Can be "season" and theoretically "series", but instead of having an attribute "series", the type attribute is left out
      // [season]: Only makes sense if [type]="season". A value of 0 is valid (for specials), a value of -1 is the same as if [type]="series" (or no type attribute)
      // [colors]: Contains three RGB colors in decimal format and pipe delimited (e.g. "|49,56,66|180,167,159|216,216,216|"). These are colors the artist picked
      //           that go well with the image. In order they are Light Accent Color, Dark Accent Color and Neutral Midtone Color. Only shows if [aspect]="fanart"
      //           (or the element is a child of <fanart>).
      var thumb = await ParseSimpleImageAsync(element, nfoDirectoryFsra).ConfigureAwait(false);
      if (thumb == null)
        return false;
      var result = new SeriesThumbStub { Thumb = thumb };
      
      var aspect = ParseStringAttribute(element, "aspect");
      switch (aspect)
      {
        case null:
          result.Aspect = SeriesThumbStub.ThumbAspect.Fanart;
          break;
        case "banner":
          result.Aspect = SeriesThumbStub.ThumbAspect.Banner;
          break;
        case "poster":
          result.Aspect = SeriesThumbStub.ThumbAspect.Poster;
          break;
        default:
          _debugLogger.Warn("[#{0}]: Unknown aspect attribute in thumb element: {1}", _miNumber, aspect);
          break;
      }

      var type = ParseStringAttribute(element, "type");
      if (type != null)
      {
        if (type == "season")
        {
          var season = ParseIntAttribute(element, "season");
          if (season.HasValue && season.Value >= 0)
            result.Season = season.Value;
        }
        else
          _debugLogger.Warn("[#{0}]: Unknown type attribute in thumb element: {1}", _miNumber, type);
      }

      var colors = ParseStringAttribute(element, "colors");
      if (colors != null)
      {
        var separatedColors = colors.Split('|');
        if (separatedColors.Count() == 5)
        {
          result.LightAccentColor = ParseColor(separatedColors[1]);
          result.DarkAccentColor = ParseColor(separatedColors[2]);
          result.NeutralMidtoneColor = ParseColor(separatedColors[3]);
        }
        else
          _debugLogger.Warn("[#{0}]: Invalid colors attribute in thumb element: {1}", _miNumber, colors);
      }

      if (_currentStub.Thumbs == null)
        _currentStub.Thumbs = new HashSet<SeriesThumbStub>();
      _currentStub.Thumbs.Add(result);
      return true;
    }

    /// <summary>
    /// Example of a valid element:
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <param name="nfoDirectoryFsra"><see cref="IFileSystemResourceAccessor"/> to the parent directory of the nfo-file</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private async Task<bool> TryReadFanArtAsync(XElement element, IFileSystemResourceAccessor nfoDirectoryFsra)
    {
      // For examples of valid element values c of NfoReaderBase.ParseMultipleImagesAsync
      // <fanart url="http://thetvdb.com/banners/">
      //   [One or more child elements that can be parsed by TryReadThumbAsync]
      // </fanart>
      // The url attribute is optional, but if it is present, its value will be prepended to every child element's content
      if (element == null || !element.HasElements)
        return false;
      var urlPrefix = ParseStringAttribute(element, "url");
      var result = false;
      foreach (var childElement in element.Elements())
      {
        if (childElement.Name != "thumb")
        {
          _debugLogger.Warn("[#{0}]: Invalid child element in fanart element: {1}", _miNumber, childElement);
          continue;
        }
        if (urlPrefix != null)
          childElement.Value = urlPrefix + childElement.Value;
        if (await TryReadThumbAsync(childElement, nfoDirectoryFsra).ConfigureAwait(false))
          result = true;
      }
      return result;
    }

    #endregion

    #region Certification and ratings

    /// <summary>
    /// Tries to read a mpaa value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadMpaa(XElement element)
    {
      // Examples of valid elements:
      // <mpaa>12</mpaa>
      // <mpaa>DE:FSK 12</mpaa>
      // <mpaa>DE:FSK 12 / DE:FSK12 / DE:12 / DE:ab 12</mpaa>
      return ((_currentStub.Mpaa = ParseCharacterSeparatedStrings(element, _currentStub.Mpaa)) != null);
    }

    /// <summary>
    /// Tries to read the rating value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadRating(XElement element)
    {
      // Example of a valid element:
      // <rating>8.5</rating>
      // A value of 0 (zero) is ignored
      var value = ParseSimpleDecimal(element);
      if (value == null || value.Value == decimal.Zero)
        return false;
      _currentStub.Rating = value;
      return true;
    }

    /// <summary>
    /// Tries to read the votes value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadVotes(XElement element)
    {
      // Example of a valid element:
      // <votes>2941</votes>
      // A value of 0 (zero) is ignored
      var value = ParseSimpleInt(element);
      if (value == 0)
        value = null;
      return ((_currentStub.Votes = value) != null);
    }

    /// <summary>
    /// Tries to read the top250 value
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to read from</param>
    /// <returns><c>true</c> if a value was found in <paramref name="element"/>; otherwise <c>false</c></returns>
    private bool TryReadTop250(XElement element)
    {
      // Examples of valid elements:
      // <top250>250</top250>
      // <top250>0</top250>
      // A value of 0 (zero) is ignored
      var value = ParseSimpleInt(element);
      if (value == 0)
        value = null;
      return ((_currentStub.Top250 = value) != null);
    }

    #endregion

    #endregion

    #region Writer methods to store metadata in MediaItemAspects

    #region MediaAspect

    /// <summary>
    /// Tries to write metadata into <see cref="MediaAspect.ATTR_TITLE"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteMediaAspectTitle(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].ShowTitle != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, MediaAspect.ATTR_TITLE, _stubs[0].ShowTitle);
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="MediaAspect.ATTR_SORT_TITLE"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteMediaAspectSortTitle(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      // priority 1:
      if (_stubs[0].SortTitle != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, MediaAspect.ATTR_SORT_TITLE, _stubs[0].SortTitle);
        return true;
      }

      // priority 2:
      if (_stubs[0].ShowTitle != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, MediaAspect.ATTR_SORT_TITLE, BaseInfo.GetSortTitle(_stubs[0].ShowTitle));
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="MediaAspect.ATTR_RECORDINGTIME"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteMediaAspectRecordingTime(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      // priority 1:
      if (_stubs[0].Premiered.HasValue)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, MediaAspect.ATTR_RECORDINGTIME, _stubs[0].Premiered.Value);
        return true;
      }
      //priority 2:
      if (_stubs[0].Year.HasValue)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, MediaAspect.ATTR_RECORDINGTIME, _stubs[0].Year.Value);
        return true;
      }
      return false;
    }

    #endregion

    #region SeriesAspect

    /// <summary>
    /// Tries to write metadata into <see cref="GenreAspect.ATTR_GENRE"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectGenres(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].Genres != null && _stubs[0].Genres.Any())
      {
        List<GenreInfo> genres = _stubs[0].Genres.Where(s => !string.IsNullOrEmpty(s?.Trim())).Select(s => new GenreInfo { Name = s.Trim() }).ToList();
        IGenreConverter converter = ServiceRegistration.Get<IGenreConverter>();
        foreach (var genre in genres)
        {
          if (!genre.Id.HasValue && converter.GetGenreId(genre.Name, GenreCategory.Series, null, out int genreId))
            genre.Id = genreId;
        }
        foreach (GenreInfo genre in genres)
        {
          MultipleMediaItemAspect genreAspect = MediaItemAspect.CreateAspect(extractedAspectData, GenreAspect.Metadata);
          genreAspect.SetAttribute(GenreAspect.ATTR_ID, genre.Id);
          genreAspect.SetAttribute(GenreAspect.ATTR_GENRE, genre.Name);
        }
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_ACTORS"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectActors(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      List<string> actors = null;
      List<string> characters = null;
      if (_stubs[0].Actors != null)
      {
        actors = _stubs.SelectMany(e => e.Actors).OrderBy(actor => actor.Order).Where(actor => !string.IsNullOrEmpty(actor.Name)).
          Select(actor => actor.Name).Distinct().ToList();
        characters = _stubs.SelectMany(e => e.Actors).OrderBy(actor => actor.Order).Where(actor => !string.IsNullOrEmpty(actor.Role)).
          Select(actor => actor.Role).Distinct().ToList();
      }
      if (actors != null && actors.Any())
      {
        MediaItemAspect.SetCollectionAttribute(extractedAspectData, SeriesAspect.ATTR_ACTORS, actors);
        if (characters != null && characters.Any())
          MediaItemAspect.SetCollectionAttribute(extractedAspectData, SeriesAspect.ATTR_CHARACTERS, characters);
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_DESCRIPTION"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectDescription(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      // priority 1:
      if (_stubs[0].Plot != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_DESCRIPTION, _stubs[0].Plot);
        return true;
      }
      // priority 2:
      if (_stubs[0].Outline != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_DESCRIPTION, _stubs[0].Outline);
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into external id.
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectTvDbId(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      //priority 1:
      if (_stubs[0].Id.HasValue)
      {
        MediaItemAspect.AddOrUpdateExternalIdentifier(extractedAspectData, ExternalIdentifierAspect.SOURCE_TVDB, ExternalIdentifierAspect.TYPE_SERIES, _stubs[0].Id.Value.ToString());
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_SERIES_NAME"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectSeriesName(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].ShowTitle != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_SERIES_NAME,
          CultureInfo.InvariantCulture.TextInfo.ToTitleCase(_stubs[0].ShowTitle));
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_TOTAL_RATING"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectTotalRating(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].Rating.HasValue)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_TOTAL_RATING, (double)_stubs.Where(e => e.Rating.HasValue).Average(e => e.Rating.Value));
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_RATING_COUNT"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectRatingCount(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].Votes.HasValue && _stubs[0].Rating.HasValue)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_RATING_COUNT, _stubs[0].Votes.Value);
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_ENDED"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectEnded(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].Status != null)
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_ENDED, _stubs[0].Status.Contains("End"));
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect..ATTR_CERTIFICATION"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectCertification(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      CertificationMapping certification;
      if (_stubs[0].Mpaa != null && TryGetCertification(_stubs[0].Mpaa, out certification))
      {
        MediaItemAspect.SetAttribute(extractedAspectData, SeriesAspect.ATTR_CERTIFICATION, certification.CertificationId);
        return true;
      }
      return false;
    }

    /// <summary>
    /// Tries to write metadata into <see cref="SeriesAspect.ATTR_NETWORKS"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteSeriesAspectNetworks(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].Studio != null)
      {
        MediaItemAspect.SetCollectionAttribute(extractedAspectData, SeriesAspect.ATTR_NETWORKS, new[] { _stubs[0].Studio });
        return true;
      }
      return false;
    }

    #endregion

    #region ThumbnailLargeAspect

    /// <summary>
    /// Tries to write metadata into <see cref="ThumbnailLargeAspect.ATTR_THUMBNAIL"/>
    /// </summary>
    /// <param name="extractedAspectData">Dictionary of <see cref="MediaItemAspect"/>s to write into</param>
    /// <returns><c>true</c> if any information was written; otherwise <c>false</c></returns>
    private bool TryWriteThumbnailLargeAspectThumbnail(IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      if (_stubs[0].Thumbs != null && _stubs[0].Thumbs.Any())
      {
        MediaItemAspect.SetAttribute(extractedAspectData, ThumbnailLargeAspect.ATTR_THUMBNAIL, _stubs[0].Thumbs.First().Thumb);
        return true;
      }
      return false;
    }

    #endregion

    #region Relationships

    private bool TryWriteActorAspect(PersonStub person, IDictionary<Guid, IList<MediaItemAspect>> extractedAspectData)
    {
      return TryWritePersonAspect(person, PersonAspect.OCCUPATION_ACTOR, extractedAspectData);
    }

    #endregion

    #endregion

    #region General helper methods

    /// <summary>
    /// Ignores the respective element
    /// </summary>
    /// <param name="element"><see cref="XElement"/> to ignore</param>
    /// <returns><c>false</c></returns>
    /// <remarks>
    /// We use this method as TryReadElementDelegate for elements, of which we know that they are irrelevant in the context of a series,
    /// but which are nevertheless contained in some series' nfo-files. Having this method registered as handler delegate avoids that
    /// the respective xml element is logged as unknown element.
    /// </remarks>
    private static bool Ignore(XElement element)
    {
      return false;
    }

    /// <summary>
    /// Parses a string like "20,50,100" into a <see cref="SeriesThumbStub.Color"/> object
    /// </summary>
    /// <param name="colorString">String to parse</param>
    /// <returns>A valid <see cref="SeriesThumbStub.Color"/> object or <c>null</c> if parsing was not possible</returns>
    private SeriesThumbStub.Color ParseColor(string colorString)
    {
      var separatedRgb = colorString.Split(',');
      if (separatedRgb.Count() != 3)
      {
        _debugLogger.Warn("[#{0}]: Invalid colors attribute in thumb element: {1}", _miNumber, colorString);
        return null;
      }
      byte r;
      if (!byte.TryParse(separatedRgb[0], out r))
      {
        _debugLogger.Warn("[#{0}]: Invalid colors attribute in thumb element: {1}", _miNumber, colorString);
        return null;
      }
      byte g;
      if (!byte.TryParse(separatedRgb[1], out g))
      {
        _debugLogger.Warn("[#{0}]: Invalid colors attribute in thumb element: {1}", _miNumber, colorString);
        return null;
      }
      byte b;
      if (!byte.TryParse(separatedRgb[2], out b))
      {
        _debugLogger.Warn("[#{0}]: Invalid colors attribute in thumb element: {1}", _miNumber, colorString);
        return null;
      }
      return new SeriesThumbStub.Color(r, g, b);
    }

    protected bool TryGetCertification(IEnumerable<string> certifications, out CertificationMapping certificationMapping)
    {
      if (certifications != null)
        foreach (string certification in certifications)
          if (CertificationMapper.TryFindSeriesCertification(certification, out certificationMapping))
            return true;
      certificationMapping = null;
      return false;
    }

    #endregion

    #endregion

    #region Public methods

    /// <summary>
    /// Gets the <see cref="SeriesStub"/> objects generated by this class
    /// </summary>
    /// <returns>List of <see cref="SeriesStub"/> objects</returns>
    public List<SeriesStub> GetSeriesStubs()
    {
      return _stubs;
    }

    public bool TryWriteActorMetadata(IList<IDictionary<Guid, IList<MediaItemAspect>>> extractedAspects)
    {
      if (_stubs[0].Actors == null)
        return false;
      //Distinct actor names, ordered by Order
      IEnumerable<PersonStub> actors = _stubs[0].Actors
        .Where(a => !string.IsNullOrEmpty(a.Name))
        .GroupBy(a => a.Name).Select(g => g.First())
        .OrderBy(a => a.Order);
      return TryWriteRelationshipMetadata(TryWriteActorAspect, actors, extractedAspects);
    }

    public bool TryWriteCharacterMetadata(IList<IDictionary<Guid, IList<MediaItemAspect>>> extractedAspects)
    {
      if (_stubs[0].Actors == null)
        return false;
      //Distinct actor names, ordered by Order
      IEnumerable<PersonStub> actors = _stubs[0].Actors
        .Where(a => !string.IsNullOrEmpty(a.Name))
        .GroupBy(a => a.Name).Select(g => g.First())
        .OrderBy(a => a.Order);
      return TryWriteRelationshipMetadata(TryWriteCharacterAspect, actors, extractedAspects);
    }

    #endregion

    #region BaseOverrides

    /// <summary>
    /// Checks whether the <paramref name="itemRootElement"/>'s name is "tvshow"
    /// </summary>
    /// <param name="itemRootElement">Element to check</param>
    /// <returns><c>true</c> if the element's name is "tvshow"; else <c>false</c></returns>
    protected override bool CanReadItemRootElementTree(XElement itemRootElement)
    {
      var itemRootElementName = itemRootElement.Name.ToString();
      if (itemRootElementName == SERIES_ROOT_ELEMENT_NAME)
        return true;
      _debugLogger.Warn("[#{0}]: Cannot extract metadata; name of the item root element is {1} instead of {2}", _miNumber, itemRootElementName, SERIES_ROOT_ELEMENT_NAME);
      return false;
    }

    /// <summary>
    /// Tries to read a series nfo-file into <see cref="SeriesStub"/> objects (or gets them from cache)
    /// </summary>
    /// <param name="nfoFsra"><see cref="IFileSystemResourceAccessor"/> pointing to the nfo-file</param>
    /// <returns><c>true</c> if any usable metadata was found; else <c>false</c></returns>
    public override async Task<bool> TryReadMetadataAsync(IFileSystemResourceAccessor nfoFsra)
    {
      var stubs = await CACHE.GetValue(nfoFsra.CanonicalLocalResourcePath, async path =>
      {
        _debugLogger.Info("[#{0}]: SeriesStub object for series nfo-file not found in cache; parsing nfo-file {1}", _miNumber, nfoFsra.CanonicalLocalResourcePath);
        if (await base.TryReadMetadataAsync(nfoFsra).ConfigureAwait(false))
        {
          if (_settings.EnableDebugLogging && _settings.WriteStubObjectIntoDebugLog)
            LogStubObjects();
          return _stubs;
        }
        return null;
      }).ConfigureAwait(false);
      if (stubs == null)
        return false;
      _stubs = stubs;
      return true;
    }

    #endregion
  }
}
