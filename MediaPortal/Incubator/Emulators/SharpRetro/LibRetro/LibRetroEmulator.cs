using SharpRetro.Controller;
using SharpRetro.RetroGL;
using SharpRetro.Utils;
using SharpRetro.Video;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace SharpRetro.LibRetro
{
  public delegate void LogDelegate(RETRO_LOG_LEVEL level, string message);

  /// <summary>
  /// Implements the LibRetro API, enabling the loading and running of LibRetro cores
  /// </summary>
  public unsafe class LibRetroEmulator : LibRetroBase
  {
    #region LibRetro Interfaces
    retro_log_printf_t retro_log_printf_cb;
    retro_perf_callback retro_perf_callback = new retro_perf_callback();
    retro_rumble_interface retro_rumble_interface = new retro_rumble_interface();
    #endregion

    #region Protected Members
    protected const short TRUE_SHORT = 1;
    protected const short FALSE_SHORT = 0;
    
    protected UnmanagedResourceHeap _unmanagedResources = new UnmanagedResourceHeap();
    protected LibRetroVariables _variables = new LibRetroVariables();
    protected LogDelegate _logDelegate;

    protected bool _firstRun = true;
    protected string _systemDirectory;
    protected string _saveDirectory;
    protected bool _canDupe = true;
    protected uint _performanceLevel;

    protected bool _supportsNoGame;
    protected IRetroGLContext _glContext;
    protected int[] _videoBuffer;
    protected int _maxVideoWidth;
    protected int _maxVideoHeight;
    protected AudioBuffer _audioBuffer;
    protected bool _hasHWRenderer;

    protected SystemInfo _systemInfo;
    protected VideoInfo _videoInfo;
    protected TimingInfo _timingInfo;
    protected RETRO_PIXEL_FORMAT _pixelFormat = RETRO_PIXEL_FORMAT.XRGB1555;

    protected IRetroController _retroController;
    protected IRetroPad _retroPad;
    protected IRetroAnalog _retroAnalog;
    protected IRetroKeyboard _retroKeyboard;
    protected IRetroPointer _retroPointer;
    protected IRetroRumble _retroRumble;
    #endregion

    #region Public Properties
    /// <summary>
    /// Gets or sets a delegate to use for logging
    /// </summary>
    public LogDelegate LogDelegate
    {
      get { return _logDelegate; }
      set { _logDelegate = value; }
    }

    /// <summary>
    /// Gets or sets an OpenGL context that RetroGL cores can render to
    /// </summary>
    public IRetroGLContext GLContext
    {
      get { return _glContext; }
      set { _glContext = value; }
    }

    /// <summary>
    /// Gets or sets a controller interface to use for polling for input events
    /// </summary>
    public IRetroController Controller
    {
      get { return _retroController; }
      set
      {
        _retroController = value;
        _retroPad = value as IRetroPad;
        _retroAnalog = value as IRetroAnalog;
        _retroKeyboard = value as IRetroKeyboard;
        _retroPointer = value as IRetroPointer;
        _retroRumble = value as IRetroRumble;
      }
    }

    /// <summary>
    /// Gets or sets the system directory to pass to the LibRetro core
    /// </summary>
    public string SystemDirectory
    {
      get { return _systemDirectory; }
      set { _systemDirectory = value; }
    }

    /// <summary>
    /// Gets or sets the save directory to provide to the LibRetro core
    /// </summary>
    public string SaveDirectory
    {
      get { return _saveDirectory; }
      set { _saveDirectory = value; }
    }

    /// <summary>
    /// Gets the system information provided by the LibRetro core
    /// </summary>
    public SystemInfo SystemInfo
    {
      get { return _systemInfo; }
    }

    /// <summary>
    /// Gets the available variables defined by the LibRetro core and allows variables to be set
    /// </summary>
    public LibRetroVariables Variables
    {
      get { return _variables; }
    }

    /// <summary>
    /// Gets information about the video output of the LibRetro core.
    /// Potentially updated every time the video buffer/OpenGL context is updated
    /// </summary>
    public VideoInfo VideoInfo
    {
      get { return _videoInfo; }
    }

    /// <summary>
    /// Gets the timing information provided by the LibRetro core
    /// </summary>
    public TimingInfo TimingInfo
    {
      get { return _timingInfo; }
    }

    /// <summary>
    /// Gets the pixel data of the last video frame generated by the LibRetro core.
    /// Not used for RetroGL cores, they directly render to an OpenGL frame buffer provided by the <see cref="GLContext"/>
    /// </summary>
    public int[] VideoBuffer
    {
      get { return _videoBuffer; }
    }

    /// <summary>
    /// Gets the audio data of the last audio frame generated by the LibRetro core.
    /// </summary>
    public AudioBuffer AudioBuffer
    {
      get { return _audioBuffer; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the frontend can duplicate video frames 
    /// </summary>
    public bool CanDupeFrame
    {
      get { return _canDupe; }
      set { _canDupe = value; }
    }

    public bool SupportsNoGame
    {
      get { return _supportsNoGame; }
    }

    /// <summary>
    /// Gets the suggested performance level of the frontend.
    /// Values range from 1 - 15, where 1 is low performance and 15 high performance.
    /// </summary>
    public uint PerformanceLevel
    {
      get { return _performanceLevel; }
    }
    #endregion

    #region Events
    /// <summary>
    /// Fired when the <see cref="VideoBuffer"/> has been updated
    /// </summary>
    public event EventHandler VideoReady;
    protected virtual void OnVideoReady()
    {
      var handler = VideoReady;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }

    /// <summary>
    /// Fired when the FrameBuffer provided by the <see cref="GLContext"/> has been updated
    /// </summary>
    public event EventHandler FrameBufferReady;
    protected virtual void OnFrameBufferReady()
    {
      var handler = FrameBufferReady;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }

    /// <summary>
    /// Fired when the <see cref="AudioBuffer"/> has been updated
    /// </summary>
    public event EventHandler AudioReady;
    protected virtual void OnAudioReady()
    {
      var handler = AudioReady;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }

    /// <summary>
    /// Fired when the AVInfo has been updated
    /// </summary>
    public event EventHandler AVInfoUpdated;
    protected virtual void OnAVInfoUpdated()
    {
      var handler = AVInfoUpdated;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }
    #endregion

    #region Ctor
    /// <summary>
    /// 
    /// </summary>
    /// <param name="corePath">The path to the LibRetro core to load</param>
    public LibRetroEmulator(string corePath)
    : base(corePath)
    {
    }
    #endregion

    #region Init/Deinit
    /// <summary>
    /// Initializes the LibRetro core
    /// </summary>
    public override void Init()
    {
      try
      {
        InitInterfaces();
        InitPaths();
        base.Init();
        retro_init();
        UpdateSystemInfo();
      }
      catch
      {
        Dispose();
        throw;
      }
    }

    /// <summary>
    /// Deinitialize the LibRetro core
    /// </summary>
    public void DeInit()
    {
      //Mupen64 crashes if deinit is called when run hasn't been called
      if (!_firstRun)
        retro_deinit();
    }

    protected void InitInterfaces()
    {
      retro_log_printf_cb = new retro_log_printf_t(RetroLogPrintf);
      retro_rumble_interface.set_rumble_state = new retro_set_rumble_state_t(RetroSetRumbleState);

      //no way (need new mechanism) to check for SSSE3, MMXEXT, SSE4, SSE42
      retro_perf_callback.get_cpu_features = new retro_get_cpu_features_t(() => (ulong)(
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsXMMIAvailable) ? RETRO_SIMD.SSE : 0) |
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsXMMI64Available) ? RETRO_SIMD.SSE2 : 0) |
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsSSE3Available) ? RETRO_SIMD.SSE3 : 0) |
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsMMXAvailable) ? RETRO_SIMD.MMX : 0)
        ));
      retro_perf_callback.get_perf_counter = new retro_perf_get_counter_t(() => System.Diagnostics.Stopwatch.GetTimestamp());
      retro_perf_callback.get_time_usec = new retro_perf_get_time_usec_t(() => DateTime.Now.Ticks / 10);
      retro_perf_callback.perf_log = new retro_perf_log_t(() => { });
      retro_perf_callback.perf_register = new retro_perf_register_t((ref retro_perf_counter counter) => { });
      retro_perf_callback.perf_start = new retro_perf_start_t((ref retro_perf_counter counter) => { });
      retro_perf_callback.perf_stop = new retro_perf_stop_t((ref retro_perf_counter counter) => { });
    }

    protected void InitPaths()
    {
      if (string.IsNullOrEmpty(_systemDirectory))
        _systemDirectory = Path.GetDirectoryName(_corePath);
      if (string.IsNullOrEmpty(_saveDirectory))
        _saveDirectory = Path.GetDirectoryName(_corePath);
    }

    protected void UpdateSystemInfo()
    {
      retro_system_info system_info = new retro_system_info();
      retro_get_system_info(ref system_info);
      _systemInfo = new SystemInfo()
      {
        LibraryName = Marshal.PtrToStringAnsi(system_info.library_name),
        LibraryVersion = Marshal.PtrToStringAnsi(system_info.library_version),
        ValidExtensions = Marshal.PtrToStringAnsi(system_info.valid_extensions),
        NeedsFullPath = system_info.need_fullpath,
        BlockExtract = system_info.block_extract
      };
    }
    #endregion

    #region Load Game
    /// <summary>
    /// Loads the specified game.
    /// </summary>
    /// <param name="path">The path to the game to load</param>
    /// <param name="data">If <see cref="SystemInfo.NeedsFullPath"/> is <c>false</c> this should be a byte array containing the game. Otherwise <c>null</c></param>
    /// <returns>True if the game was loaded successfully</returns>
    public bool LoadGame(string path, byte[] data)
    {
      return LoadGame(path, data, "");
    }

    /// <summary>
    /// Loads the specified game.
    /// </summary>
    /// <param name="path">The path to the game to load</param>
    /// <param name="data">If <see cref="SystemInfo.NeedsFullPath"/> is <c>false</c> this should be a byte array containing the game. Otherwise <c>null</c></param>
    /// <param name="meta">The metadata to pass to the core</param>
    /// <returns>True if the game was loaded successfully</returns>
    public bool LoadGame(string path, byte[] data, string meta)
    {
      retro_game_info gameInfo = new retro_game_info();
      gameInfo.path = path;
      gameInfo.meta = meta;
      if (data == null || data.Length == 0)
        return LoadGame(gameInfo);

      fixed (byte* p = &data[0])
      {
        gameInfo.data = (IntPtr)p;
        gameInfo.size = (uint)data.Length;
        return LoadGame(gameInfo);
      }
    }

    /// <summary>
    /// Loads the specified game.
    /// </summary>
    /// <param name="gameInfo">The game to load</param>
    /// <returns>True if the game was loaded successfully</returns>
    public bool LoadGame(retro_game_info gameInfo)
    {
      if (!retro_load_game(ref gameInfo))
      {
        Log(RETRO_LOG_LEVEL.WARN, "retro_load_game() failed");
        return false;
      }
      GetAVInfo();
      return true;
    }

    /// <summary>
    /// 
    /// </summary>
    public void Reset()
    {
      retro_reset();
    }

    /// <summary>
    /// Unloads the currently loaded game
    /// </summary>
    public void UnloadGame()
    {
      retro_unload_game();
    }

    protected void GetAVInfo()
    {
      retro_system_av_info av = new retro_system_av_info();
      retro_get_system_av_info(ref av);
      _maxVideoWidth = (int)av.geometry.max_width;
      _maxVideoHeight = (int)av.geometry.max_height;
      _videoBuffer = new int[_maxVideoWidth * _maxVideoHeight];
      _audioBuffer = new AudioBuffer();
      _audioBuffer.Data = new short[2];
      _videoInfo = new VideoInfo((int)av.geometry.base_width, (int)av.geometry.base_height, av.geometry.aspect_ratio);
      _timingInfo = new TimingInfo(av.timing.fps, av.timing.sample_rate);
    }
    #endregion

    #region Run
    /// <summary>
    /// Advances the currently loaded game by 1 frame
    /// </summary>
    public void Run()
    {
      CheckGLContextStatus();
      retro_run();
    }

    protected void CheckGLContextStatus()
    {
      if (!_firstRun)
        return;
      _firstRun = false;
      if (_hasHWRenderer && _glContext != null)
        _glContext.Create(_maxVideoWidth, _maxVideoHeight);
    }
    #endregion

    #region Memory
    /// <summary>
    /// Returns the size of the specified memory type
    /// </summary>
    /// <param name="memoryType">The type of memory</param>
    /// <returns>The size of the memory type</returns>
    public int GetMemorySize(RETRO_MEMORY memoryType)
    {
      return (int)retro_get_memory_size(memoryType);
    }

    /// <summary>
    /// Writes the specified memory data to the provided buffer
    /// </summary>
    /// <param name="memoryType">The type of memory</param>
    /// <param name="buffer">A buffer to write the memory to. This should be at least the size returned by <see cref="GetMemorySize(RETRO_MEMORY)"/></param>
    /// <returns>True if the memory data was successfully retrieved</returns>
    public bool GetMemoryData(RETRO_MEMORY memoryType, byte[] buffer)
    {
      int size = (int)retro_get_memory_size(memoryType);
      if (size == 0)
        return false;
      IntPtr ptr = retro_get_memory_data(memoryType);
      if (ptr == IntPtr.Zero)
        return false;
      Marshal.Copy(ptr, buffer, 0, size);
      return true;
    }

    /// <summary>
    /// Convenience method for <see cref="GetMemoryData(RETRO_MEMORY, byte[])"/> that allocates and returns a buffer containing the memory data
    /// </summary>
    /// <param name="memoryType">The type of memory to retrieve</param>
    /// <returns>A byte array containing the memory data</returns>
    public byte[] GetMemoryData(RETRO_MEMORY memoryType)
    {
      uint size = retro_get_memory_size(memoryType);
      if (size == 0)
        return null;
      IntPtr ptr = retro_get_memory_data(memoryType);
      if (ptr == IntPtr.Zero)
        return null;
      byte[] saveBuffer = new byte[size];
      Marshal.Copy(ptr, saveBuffer, 0, saveBuffer.Length);
      return saveBuffer;
    }

    /// <summary>
    /// Loads memory data of the specified type into the LibRetro core
    /// </summary>
    /// <param name="memoryType">The type of memory to load</param>
    /// <param name="buffer">A byte array containing the memory data</param>
    /// <returns>True if the memory data was successfully loaded</returns>
    public bool SetMemoryData(RETRO_MEMORY memoryType, byte[] buffer)
    {
      int size = GetMemorySize(memoryType);
      if (size > buffer.Length)
        size = buffer.Length;
      IntPtr ptr = retro_get_memory_data(memoryType);
      if (ptr == IntPtr.Zero)
        return false;
      Marshal.Copy(buffer, 0, ptr, size);
      return true;
    }

    /// <summary>
    /// Gets the size of the serialized state
    /// </summary>
    /// <returns>The size of the serialized state</returns>
    public int GetSerializeSize()
    {
      return (int)retro_serialize_size();
    }

    /// <summary>
    /// Serializes the current state of the LibRetro core to the provided buffer
    /// </summary>
    /// <param name="buffer">The buffer to write the serialized state to. This should be at least the size returned by <see cref="GetSerializeSize"/></param>
    /// <returns>True if the state was successfully serialized</returns>
    public bool Serialize(byte[] buffer)
    {
      uint size = retro_serialize_size();
      if (size == 0)
        return false;
      fixed (byte* p = &buffer[0])
        return retro_serialize((IntPtr)p, size);
    }

    /// <summary>
    /// Convenience method for <see cref="Serialize(byte[])"/> that allocates and returns a buffer containing the serialized state
    /// </summary>
    /// <returns>A buffer containing the current state of the LibRetro core if successful, otherwise null</returns>
    public byte[] Serialize()
    {
      uint size = retro_serialize_size();
      byte[] buffer = new byte[size];
      bool result;
      fixed (byte* p = &buffer[0])
        result = retro_serialize((IntPtr)p, size);
      return result ? buffer : null;
    }

    /// <summary>
    /// Unserializes a serialized state into the LibRetro core
    /// </summary>
    /// <param name="buffer">A buffer containing the serialized state</param>
    public void Unserialize(byte[] buffer)
    {
      uint size = retro_serialize_size();
      fixed (byte* p = &buffer[0])
        retro_unserialize((IntPtr)p, size);
    }
    #endregion

    #region Environment
    protected override bool RetroEnvironment(RETRO_ENVIRONMENT cmd, IntPtr data)
    {      
      //Log("Environment: {0}", cmd);
      switch (cmd)
      {
        case RETRO_ENVIRONMENT.SET_ROTATION:
          return false;
        case RETRO_ENVIRONMENT.GET_OVERSCAN:
          return false;
        case RETRO_ENVIRONMENT.GET_CAN_DUPE:
          *(bool*)data.ToPointer() = _canDupe;
          return true;
        case RETRO_ENVIRONMENT.SET_MESSAGE:
          return SetMessage(data);
        case RETRO_ENVIRONMENT.SHUTDOWN:
          return false;
        case RETRO_ENVIRONMENT.SET_PERFORMANCE_LEVEL:
          _performanceLevel = *(uint*)data.ToPointer();
          Log(RETRO_LOG_LEVEL.DEBUG, "Core suggested SET_PERFORMANCE_LEVEL {0}", _performanceLevel);
          return true;
        case RETRO_ENVIRONMENT.GET_SYSTEM_DIRECTORY:
          Log(RETRO_LOG_LEVEL.DEBUG, "returning system directory: " + _systemDirectory);
          return SetDirectory(data, _systemDirectory);
        case RETRO_ENVIRONMENT.SET_PIXEL_FORMAT:
          return SetPixelFormat(data);
        case RETRO_ENVIRONMENT.SET_INPUT_DESCRIPTORS:
          return false;
        case RETRO_ENVIRONMENT.SET_KEYBOARD_CALLBACK:
          return false;
        case RETRO_ENVIRONMENT.SET_DISK_CONTROL_INTERFACE:
          return false;
        case RETRO_ENVIRONMENT.SET_HW_RENDER:
          return InitGlContext(data);
        case RETRO_ENVIRONMENT.GET_VARIABLE:
          return GetVariable(data);
        case RETRO_ENVIRONMENT.SET_VARIABLES:
          return SetVariables(data);
        case RETRO_ENVIRONMENT.GET_VARIABLE_UPDATE:
          return _variables.Updated;
        case RETRO_ENVIRONMENT.SET_SUPPORT_NO_GAME:
          _supportsNoGame = true;
          return true;
        case RETRO_ENVIRONMENT.GET_LIBRETRO_PATH:
          Log(RETRO_LOG_LEVEL.DEBUG, "returning libretro path: " + _corePath);
          *((IntPtr*)data.ToPointer()) = _unmanagedResources.StringToHGlobalAnsiCached(_corePath);
          return true;
        case RETRO_ENVIRONMENT.SET_AUDIO_CALLBACK:
          return false;
        case RETRO_ENVIRONMENT.SET_FRAME_TIME_CALLBACK:
          return false;
        case RETRO_ENVIRONMENT.GET_RUMBLE_INTERFACE:
          Marshal.StructureToPtr(retro_rumble_interface, data, false);
          return true;
        case RETRO_ENVIRONMENT.GET_INPUT_DEVICE_CAPABILITIES:
          return false;
        case RETRO_ENVIRONMENT.GET_LOG_INTERFACE:
          *(IntPtr*)data = Marshal.GetFunctionPointerForDelegate(retro_log_printf_cb);
          return true;
        case RETRO_ENVIRONMENT.GET_PERF_INTERFACE:
          Marshal.StructureToPtr(retro_perf_callback, data, false);
          return true;
        case RETRO_ENVIRONMENT.GET_LOCATION_INTERFACE:
          return false;
        case RETRO_ENVIRONMENT.GET_CORE_ASSETS_DIRECTORY:
          return false;
        case RETRO_ENVIRONMENT.GET_SAVE_DIRECTORY:
          Log(RETRO_LOG_LEVEL.DEBUG, "returning save directory: " + _saveDirectory);
          return SetDirectory(data, _saveDirectory);
        case RETRO_ENVIRONMENT.SET_SYSTEM_AV_INFO:
          return SetAVInfo(data);
        case RETRO_ENVIRONMENT.SET_CONTROLLER_INFO:
          return true;
        case RETRO_ENVIRONMENT.SET_MEMORY_MAPS:
          return false;
        case RETRO_ENVIRONMENT.SET_GEOMETRY:
          return SetGeometry(data);
        case RETRO_ENVIRONMENT.SET_SUBSYSTEM_INFO:
          return SetSubsystemInfo(data);
        default:
          Log(RETRO_LOG_LEVEL.WARN, "Unknkown retro_environment command {0} - {1}", (int)cmd, cmd);
          return false;
      }
    }

    protected bool SetMessage(IntPtr data)
    {
      retro_message msg = new retro_message();
      Marshal.PtrToStructure(data, msg);
      if (!string.IsNullOrEmpty(msg.msg))
        Log(RETRO_LOG_LEVEL.DEBUG, "LibRetro Message: {0}", msg.msg);
      return true;
    }

    protected bool SetDirectory(IntPtr data, string directory)
    {
      if (!CreateDirectory(directory))
        return false;
      *((IntPtr*)data.ToPointer()) = _unmanagedResources.StringToHGlobalAnsiCached(directory);
      return true;
    }

    protected bool CreateDirectory(string directory)
    {
      try
      {
        Directory.CreateDirectory(directory);
        return true;
      }
      catch (Exception ex)
      {
        Log(RETRO_LOG_LEVEL.ERROR, "Error creating directory '{0}' - {1}", directory, ex);
      }
      return false;
    }

    protected bool SetPixelFormat(IntPtr data)
    {
      RETRO_PIXEL_FORMAT format = (RETRO_PIXEL_FORMAT)Marshal.ReadInt32(data);
      switch (format)
      {
        case RETRO_PIXEL_FORMAT.RGB565:
        case RETRO_PIXEL_FORMAT.XRGB1555:
        case RETRO_PIXEL_FORMAT.XRGB8888:
          _pixelFormat = format;
          Log(RETRO_LOG_LEVEL.DEBUG, "New pixel format set: {0}", _pixelFormat);
          return true;
        default:
          Log(RETRO_LOG_LEVEL.DEBUG, "Unrecognized pixel format: {0}", (int)format);
          return false;
      }
    }

    protected bool GetVariable(IntPtr data)
    {
      void** variablesPtr = (void**)data.ToPointer();
      IntPtr pKey = new IntPtr(*variablesPtr++);
      string key = Marshal.PtrToStringAnsi(pKey);
      Log(RETRO_LOG_LEVEL.DEBUG, "Requesting variable: {0}", key);
      VariableDescription variable;
      if (!_variables.TryGet(key, out variable))
      {
        Log(RETRO_LOG_LEVEL.WARN, "Variable {0}: not found", key);
        return false;
      }
      Log(RETRO_LOG_LEVEL.DEBUG, "Variable {0}: {1}", key, variable.SelectedOption);
      *variablesPtr = _unmanagedResources.StringToHGlobalAnsiCached(variable.SelectedOption).ToPointer();
      return true;
    }

    protected bool SetVariables(IntPtr data)
    {
      void** variablesPtr = (void**)data.ToPointer();
      for (;;)
      {
        IntPtr pKey = new IntPtr(*variablesPtr++);
        if (pKey == IntPtr.Zero)
          break;
        IntPtr pValue = new IntPtr(*variablesPtr++);
        VariableDescription variable = new VariableDescription(pKey, pValue);
        _variables.AddOrUpdate(variable);
        Log(RETRO_LOG_LEVEL.DEBUG, "Set variable: {0}", variable);
      }
      return true;
    }

    protected bool SetSubsystemInfo(IntPtr data)
    {      
      return true;
    }

    protected bool InitGlContext(IntPtr data)
    {
      retro_hw_render_callback* info = (retro_hw_render_callback*)data.ToPointer();
      _hasHWRenderer = true;
      Log(RETRO_LOG_LEVEL.DEBUG, "SET_HW_RENDER: {0}, version={1}.{2}, dbg/cache={3}/{4}, depth/stencil = {5}/{6}{7}", info->context_type, info->version_minor, info->version_major, info->debug_context, info->cache_context, info->depth, info->stencil, info->bottom_left_origin ? " (bottomleft)" : "");
      if (_glContext == null)
        return false;

      info->get_current_framebuffer = Marshal.GetFunctionPointerForDelegate(_glContext.GetCurrentFramebufferDlgt);
      info->get_proc_address = Marshal.GetFunctionPointerForDelegate(_glContext.GetProcAddressDlgt);

      retro_hw_context_reset_t contextReset = Marshal.GetDelegateForFunctionPointer<retro_hw_context_reset_t>(info->context_reset);
      retro_hw_context_reset_t contextDestroy = info->context_destroy != IntPtr.Zero ?
        Marshal.GetDelegateForFunctionPointer<retro_hw_context_reset_t>(info->context_destroy) : null;
      _glContext.Init(info->depth, info->stencil, info->bottom_left_origin, contextReset, contextDestroy);
      return true;
    }

    protected bool SetAVInfo(IntPtr data)
    {
      retro_system_av_info* av = (retro_system_av_info*)data.ToPointer();
      _maxVideoWidth = (int)av->geometry.max_width;
      _maxVideoHeight = (int)av->geometry.max_height;
      _videoBuffer = new int[_maxVideoWidth * _maxVideoHeight];
      _videoInfo = new VideoInfo((int)av->geometry.base_width, (int)av->geometry.base_height, av->geometry.aspect_ratio);
      _timingInfo = new TimingInfo(av->timing.fps, av->timing.sample_rate);
      OnAVInfoUpdated();
      return true;
    }

    protected bool SetGeometry(IntPtr data)
    {
      retro_game_geometry geometry = *((retro_game_geometry*)data.ToPointer());
      _videoInfo = new VideoInfo((int)geometry.base_width, (int)geometry.base_height, geometry.aspect_ratio);
      return true;
    }
    #endregion

    #region Video
    protected override void RetroVideoRefresh(IntPtr data, uint width, uint height, uint pitch)
    {
      //dupe frame
      if (data == IntPtr.Zero)
        return;

      int intWidth = (int)width;
      int intHeight = (int)height;
      _videoInfo = new VideoInfo(intWidth, intHeight, _videoInfo.DAR);
      if (data.ToInt32() == retro_hw_render_callback.RETRO_HW_FRAME_BUFFER_VALID)
        OnFrameBufferReady();
      else
        UpdateVideoBuffer(data, intWidth, intHeight, (int)pitch);
    }

    protected void UpdateVideoBuffer(IntPtr data, int width, int height, int pitch)
    {
      if (width * height > _videoBuffer.Length)
        _videoBuffer = new int[width * height];
      fixed (int* dst = &_videoBuffer[0])
        VideoBlitter.Blit(_pixelFormat, data, dst, width, height, pitch);
      OnVideoReady();
    }
    #endregion

    #region Audio
    protected override void RetroAudioSample(short left, short right)
    {
      _audioBuffer.Data[0] = left;
      _audioBuffer.Data[1] = right;
      _audioBuffer.Length = 2;
      OnAudioReady();
    }

    protected override uint RetroAudioSampleBatch(IntPtr data, uint frames)
    {
      int samples = (int)(frames * 2);
      if (_audioBuffer.Data.Length < samples)
        _audioBuffer.Data = new short[samples];
      Marshal.Copy(data, _audioBuffer.Data, 0, samples);
      _audioBuffer.Length = samples;
      OnAudioReady();
      return frames;
    }
    #endregion

    #region Input
    protected override short RetroInputState(uint port, uint device, uint index, uint id)
    {
      switch ((RETRO_DEVICE)device)
      {
        case RETRO_DEVICE.POINTER:
          return GetPointerStatus((RETRO_DEVICE_ID_POINTER)id);
        case RETRO_DEVICE.KEYBOARD:
          return GetKeyboardStatus((RETRO_KEY)id) ? TRUE_SHORT : FALSE_SHORT;
        case RETRO_DEVICE.JOYPAD:
          return GetRetroPadStatus(port, (RETRO_DEVICE_ID_JOYPAD)id) ? TRUE_SHORT : FALSE_SHORT;
        case RETRO_DEVICE.ANALOG:
          return GetAnalogStatus(port, (RETRO_DEVICE_INDEX_ANALOG)index, (RETRO_DEVICE_ID_ANALOG)id);
      }
      return 0;
    }

    protected bool RetroSetRumbleState(uint port, retro_rumble_effect effect, ushort strength)
    {
      return _retroRumble != null && _retroRumble.SetRumbleState(port, effect, strength);
    }

    protected short GetPointerStatus(RETRO_DEVICE_ID_POINTER id)
    {
      if (_retroPointer != null)
      {
        switch (id)
        {
          case RETRO_DEVICE_ID_POINTER.X: return _retroPointer.GetPointerX();
          case RETRO_DEVICE_ID_POINTER.Y: return _retroPointer.GetPointerY();
          case RETRO_DEVICE_ID_POINTER.PRESSED: return _retroPointer.IsPointerPressed() ? TRUE_SHORT : FALSE_SHORT;
        }
      }
      return 0;
    }

    protected bool GetKeyboardStatus(RETRO_KEY key)
    {
      return _retroKeyboard != null && _retroKeyboard.IsKeyPressed(key);
    }

    protected bool GetRetroPadStatus(uint port, RETRO_DEVICE_ID_JOYPAD button)
    {
      return _retroPad != null && _retroPad.IsButtonPressed(port, button);
    }

    protected short GetAnalogStatus(uint port, RETRO_DEVICE_INDEX_ANALOG analogIndex, RETRO_DEVICE_ID_ANALOG analogDirection)
    {
      return _retroAnalog != null ? _retroAnalog.GetAnalog(port, analogIndex, analogDirection) : FALSE_SHORT;
    }
    #endregion

    #region Log
    protected void RetroLogPrintf(RETRO_LOG_LEVEL level, string fmt, IntPtr a0, IntPtr a1, IntPtr a2, IntPtr a3, IntPtr a4, IntPtr a5, IntPtr a6, IntPtr a7, IntPtr a8, IntPtr a9, IntPtr a10, IntPtr a11, IntPtr a12, IntPtr a13, IntPtr a14, IntPtr a15)
    {
      if (_logDelegate == null)
        return;
      //avert your eyes, these things were not meant to be seen in c#
      //I'm not sure this is a great idea. It would suck for silly logging to be unstable. But.. I dont think this is unstable. The sprintf might just print some garbledy stuff.
      IntPtr[] args = new IntPtr[] { a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 };
      string message = Printf(fmt, args);
      _logDelegate(level, message);
    }

    protected void Log(RETRO_LOG_LEVEL level, string format, params object[] args)
    {
      if (_logDelegate != null)
        _logDelegate(level, string.Format(format, args));
    }

    protected string Printf(string format, IntPtr[] args)
    {
      int idx = 0;
      string message;
      try
      {
        message = Sprintf.sprintf(format, () => args[idx++]);
      }
      catch (Exception ex)
      {
        message = string.Format("Error in sprintf - {0}", ex);
      }
      return message;
    }
    #endregion

    #region IDisposable
    /// <summary>
    /// Disposes the LibRetro core, the OpenGL context and any unmanaged resources
    /// </summary>
    public override void Dispose()
    {
      base.Dispose();
      if (_glContext != null)
      {
        _glContext.Dispose();
        _glContext = null;
      }
      _unmanagedResources.Dispose();
    }
    #endregion
  }
}