#region Copyright (C) 2007-2021 Team MediaPortal

/*
    Copyright (C) 2007-2021 Team MediaPortal
    http://www.team-mediaportal.com

    This file is part of MediaPortal 2

    MediaPortal 2 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MediaPortal 2 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MediaPortal 2. If not, see <http://www.gnu.org/licenses/>.
*/

#endregion

using SharpLib.Hid;
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace HidInput.Windows
{
  /// <summary>
  /// Utility class that can determine which Windows generated messages should be filtered from the message queue because
  /// they were automatically generated from WM_INPUT messages that have already been handled. 
  /// </summary>
  /// <remarks>
  /// This class is necessary because Windows will generate WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN and/or WM_SYSKEYUP messages for
  /// keyboard input despite the fact that we may have already handled the keyboard input in the lower level WM_INPUT message
  /// for it, so we need to filter out those key messages so the same input isn't acted on twice.
  /// </remarks>
  public class MessageFilter
  {
    protected class FilterItem
    {
      public FilterItem(int message, int parameter)
      {
        Message = message;
        Parameter = parameter;
      }

      public int Message { get; }
      public int Parameter { get; }
    }

    protected List<FilterItem> _filteredMessageItems = new List<FilterItem>();
    protected List<AppCommand> _filteredAppCommands = new List<AppCommand>();

    /// <summary>
    /// Specifies that any subsequent messages that will be generated by the WM_INPUT message described
    /// by <paramref name="hidEvent"/> should be filtered.
    /// </summary>
    /// <param name="hidEvent">The HID event that has been handled.</param>
    public void Filter(Event hidEvent)
    {
      // For WM_INPUT keyboard messages Windows automatically generates WM_KEYDOWN/UP messages,
      // so ignore the next down/up messages for those keys
      if (hidEvent.IsKeyboard && hidEvent.IsButtonDown)
      {
        int key = (int)NormalizeKey(hidEvent.VirtualKey);
        _filteredMessageItems.Add(new FilterItem(WindowsMessageUtils.WM_KEYDOWN, key));
        _filteredMessageItems.Add(new FilterItem(WindowsMessageUtils.WM_KEYUP, key));
      }
    }

    /// <summary>
    /// Whether the message should be filtered because it was automatically generated from a previously handled WM_INPUT message.
    /// </summary>
    /// <param name="message">The windows message to possibly filter.</param>
    /// <param name="modified">Whether the message has been modified, this is independent of the return value.</param>
    /// <returns><c>true</c> if the message should be filtered.</returns>
    public bool ShouldFilter(ref Message message, out bool modified)
    {
      int msg = WindowsMessageUtils.NormalizeKeyMessageId(message.Msg);
      if (msg == WindowsMessageUtils.WM_APPCOMMAND)
        return ShouldFilterAppCommand(ref message, out modified);
      else if (msg == WindowsMessageUtils.WM_KEYDOWN || msg == WindowsMessageUtils.WM_KEYUP)
        return ShouldFilterKeyMessage(msg, ref message, out modified);

      modified = false;
      return false;
    }

    protected bool ShouldFilterAppCommand(ref Message message, out bool modified)
    {
      AppCommand appCommand = WindowsMessageUtils.GetAppCommand(ref message);
      if (_filteredAppCommands.Remove(appCommand))
      {
#if LOG_MESSAGE_FILTERING
        Log("Filtering AppCommand {0}", appCommand);
#endif
        message.Result = (IntPtr)1;
        modified = true;
        return true;
      }

      modified = false;
      return false;
    }

    protected bool ShouldFilterKeyMessage(int msg, ref Message message, out bool modified)
    {
      // Get the key
      int key = (int)NormalizeKey((Keys)message.WParam);
      modified = false;
      // A single WM_KEYDOWN message can contain repeated key presses, see how
      // many should be handled and adjust the repeat count if not all should be handled.
      int repeatCount = WindowsMessageUtils.GetRepeatCount(ref message);
      for (int i = 0; i < repeatCount; i++)
      {
        if (!Remove(_filteredMessageItems, msg, key))
        {
          // If at least one repeat has been handled
          if (i > 0)
          {
            // Remaining repeats should not be handled, modify the message to remove the repeats that have been handled
            WindowsMessageUtils.SetRepeatCount(ref message, repeatCount - i);
            modified = true;
          }
#if LOG_MESSAGE_FILTERING
        Log("Unfiltered key press {0}", message);
#endif
          return false;
        }
      }
#if LOG_MESSAGE_FILTERING
      Log("Filtering key press {0}", message);
#endif
      return true;
    }

    /// <summary>
    /// Clears the current list of items to filter.
    /// </summary>
    public void Reset()
    {
      _filteredMessageItems.Clear();
      _filteredAppCommands.Clear();
    }

    protected static bool Remove(IList<FilterItem> filterItems, int message, int parameter)
    {
      for (int i = 0; i < filterItems.Count; i++)
      {
        FilterItem item = filterItems[i];
        if (item.Message == message && item.Parameter == parameter)
        {
          filterItems.RemoveAt(i);
          return true;
        }
      }
      return false;
    }

    /// <summary>
    /// Windows message key and HID key might be different for the same key, so convert them to the same base key if needed
    /// </summary>
    private static Keys NormalizeKey(Keys key)
    {
      key &= Keys.KeyCode;

      if (key == Keys.LControlKey || key == Keys.RControlKey || key == Keys.Control)
        return Keys.ControlKey;
      if (key == Keys.LMenu || key == Keys.RMenu || key == Keys.Alt)
        return Keys.Menu;
      if (key == Keys.LShiftKey || key == Keys.RShiftKey || key == Keys.Shift)
        return Keys.ShiftKey;

      return key;
    }

#if LOG_MESSAGE_FILTERING
    protected void Log(string message, params object[] args)
    {
      MediaPortal.Common.ServiceRegistration.Get<MediaPortal.Common.Logging.ILogger>().Info("HidMessageFilter: " + message, args);
    }
#endif
  }
}
